name: ğŸš€ Deploy Terraform to Azure (Com Destroy Option)

# =====================================================
# TRIGGERS - Simplificado como o professor quer
# =====================================================
on:
  workflow_dispatch:
    inputs:
      destroy:
        description: 'ğŸ§¨ DESTRUIR infraestrutura?'
        required: true
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

permissions:
  id-token: write
  contents: read

jobs:
  # =========================================
  # JOB 1: VALIDATE - SÃ³ valida, NÃƒO formata
  # =========================================
  validate:
    if: github.event.inputs.destroy == 'false'
    name: ğŸ” Validar Terraform
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout do cÃ³digo
        uses: actions/checkout@v3

      - name: ğŸ” Login no Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ”§ Instalar Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'

      - name: ğŸ“¦ Terraform Init
        working-directory: infra
        run: |
          export ARM_SUBSCRIPTION_ID=${{ secrets.ARM_SUBSCRIPTION_ID }}
          terraform init -backend-config="key=prod.terraform.tfstate"

      # =====================================================
      # REMOVIDO: terraform fmt -check
      # POR QUÃŠ? Ele retorna cÃ³digo 1 se arquivos nÃ£o estÃ£o formatados!
      # ISSO QUEBRA O PIPELINE DESNECESSARIAMENTE
      # =====================================================
      
      - name: âœ… Terraform Validate (Sintaxe)
        working-directory: infra
        run: terraform validate

      # =====================================================
      # PLAN SEM SALVAR ARTEFATO - SÃ³ valida lÃ³gica
      # =====================================================
      - name: ğŸ“‹ Terraform Plan (Dry-run)
        working-directory: infra
        run: |
          terraform plan \
            -var="resource_group_name=${{ vars.AZURE_RG }}" \
            -var="location=${{ vars.AZURE_LOCATION }}" \
            -var="admin_password=${{ secrets.ADMIN_PASSWORD }}" \
            -input=false

  # =========================================
  # JOB 2: DEPLOY - Provisiona e Configura
  # =========================================
  deploy:
    if: github.event.inputs.destroy == 'false'
    name: ğŸš€ Deploy e ConfiguraÃ§Ã£o
    needs: validate
    runs-on: ubuntu-latest
    outputs:
      vmName: ${{ steps.output_vm.outputs.vm_name }}
      adminUsername: ${{ steps.output_vm.outputs.admin_username }}
      publicIP: ${{ steps.output_vm.outputs.public_ip }}
      nsgName: ${{ steps.output_vm.outputs.nsg_name }}
      resourceGroup: ${{ steps.output_vm.outputs.resource_group }}

    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v3

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ”§ Instalar Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'

      - name: ğŸ“¦ Terraform Init
        working-directory: infra
        run: |
          export ARM_SUBSCRIPTION_ID=${{ secrets.ARM_SUBSCRIPTION_ID }}
          terraform init -backend-config="key=prod.terraform.tfstate"

      # =====================================================
      # APLICA SEM PLAN SEPARADO - Simplificado como professor
      # =====================================================
      - name: ğŸš€ Terraform Apply
        working-directory: infra
        run: terraform apply -auto-approve

      - name: ğŸ“¤ Capturar Outputs
        id: output_vm
        working-directory: infra
        run: |
          echo "vm_name=vm-automation" >> $GITHUB_OUTPUT
          echo "admin_username=azureuser" >> $GITHUB_OUTPUT
          echo "public_ip=$(terraform output -raw public_ip_address)" >> $GITHUB_OUTPUT
          echo "nsg_name=$(terraform output -raw nsg_name)" >> $GITHUB_OUTPUT
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT

      # =====================================================
      # CONFIGURAÃ‡ÃƒO ANSIBLE - Mesma lÃ³gica do professor
      # =====================================================
      - name: ğŸ”§ Instalar Ansible e sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible sshpass

      - name: ğŸ“ Criar InventÃ¡rio Ansible
        run: |
          echo "[vm]" > inventory
          echo "${{ steps.output_vm.outputs.public_ip }} ansible_user=azureuser ansible_password=${{ secrets.ADMIN_PASSWORD }} ansible_ssh_common_args='-o StrictHostKeyChecking=no'" >> inventory

      - name: ğŸ“˜ Executar Playbook
        run: |
          ansible-playbook -i inventory ansible/playbook.yml --extra-vars "ansible_sudo_pass=${{ secrets.ADMIN_PASSWORD }}"

  # =========================================
  # JOB 3: POST-TESTS - ValidaÃ§Ã£o Final
  # =========================================
  post-tests:
    if: github.event.inputs.destroy == 'false'
    name: âœ… PÃ³s-Testes de Infra
    needs: deploy
    runs-on: ubuntu-latest
    env:
      PUBLIC_IP: ${{ needs.deploy.outputs.publicIP }}
      VM_NAME: ${{ needs.deploy.outputs.vmName }}
      NSG_NAME: ${{ needs.deploy.outputs.nsgName }}
      RESOURCE_GROUP: ${{ needs.deploy.outputs.resourceGroup }}

    steps:
      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ§ª Testar Swagger
        run: |
          echo "Aguardando aplicaÃ§Ã£o subir com Swagger..."
          sleep 30
          response=$(curl -s -o /dev/null -w "%{http_code}" http://$PUBLIC_IP:8081/swagger-ui/index.html)
          if [ "$response" != "200" ]; then
            echo "âŒ Swagger nÃ£o respondeu como esperado. Status HTTP: $response"
            exit 1
          else
            echo "âœ… Swagger disponÃ­vel em /swagger-ui/index.html na porta 8081!"
          fi

      - name: âœ… Verificar status da VM
        run: |
          status=$(az vm get-instance-view \
            --name "$VM_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --query "instanceView.statuses[?code=='PowerState/running'].displayStatus" \
            --output tsv)

          echo "Status da VM: $status"
          if [ "$status" != "VM running" ]; then
              echo "âŒ A VM nÃ£o estÃ¡ em execuÃ§Ã£o!"
              exit 1
          else
              echo "âœ… VM estÃ¡ rodando com sucesso!"
          fi

      - name: âœ… Verificar regra da NSG
        run: |
          result=$(az network nsg rule list \
            --nsg-name "$NSG_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --query "[?destinationPortRange=='8081' && access=='Allow']")

          if [ "$result" = "[]" ]; then
            echo "âŒ Porta 8081 nÃ£o estÃ¡ liberada na NSG!"
            exit 1
          else
            echo "âœ… Porta 8081 estÃ¡ liberada corretamente na NSG!"
          fi

  # =========================================
  # JOB 4: DESTROY - Limpeza
  # =========================================
  destroy:
    if: github.event.inputs.destroy == 'true'
    name: ğŸ§¨ Destruir Infraestrutura
    runs-on: ubuntu-latest

    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v3

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ”§ Instalar Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'

      - name: ğŸ“¦ Terraform Init
        working-directory: infra
        run: |
          export ARM_SUBSCRIPTION_ID=${{ secrets.ARM_SUBSCRIPTION_ID }}
          terraform init -backend-config="key=prod.terraform.tfstate"

      - name: ğŸ’¥ Terraform Destroy
        working-directory: infra
        run: terraform destroy -auto-approve
